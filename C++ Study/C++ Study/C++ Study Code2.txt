





2022-09-23 22:45:02 GMT+9

/*                         #### 9.23 네 번째 강의 ####                          */

#include "stdafx.h"

int main()
{
	//int a = 10;
	//char c = 65;		// 1 바이트 문자, 265 개 문자 표현 가능
	//short s = 65;	
	//wchar_t wc = 65;	// 2 바이트 문자. 육만오천 개, 나라별 언어 설정 가능

	// char(1), wchar_t(2) 정수형 자료형 중에 문자를 표현하는데 사용되는 자료형
	// 문자는 각 숫자에 대응, 숫자와 문자의 관계를 정리한 표가 바로 아스키코드표다.
	// 아스키코드표는 1 바이트. 딱 128 개. 영어는 1 바이트로 모두 표현 가능하다.
	// 비영어권 문자들은 1 바이트에 다 넣을 수 없으므로 2 바이트 자료형 사용.
	// 이제는 2 바이트 문자열이 주류.

	// 한글을 표현하기 위해서 2 바이트 기준 문자 자료형을 사용한다.
	
	
	// ================================================
	// 배 열
	// 1. 만들어진 배열은 연속된 메모리 구조를 가진다.
	// 2. 배열의 이름 타입은 크기 정보를 포함한다.
	// 배열의 인덱스는 0 부터 시작한다.
	// 따라서 선언 개수 - 1 인덱스까지만 접근 가능하다.
	// ================================================
	int iArr[100] = {};	// 초기에 선언하는 것이 좋다.
	
	printf("%d\n", sizeof(iArr)); // 400

	// iArr[100] 을 접근하면 터지지만 비주얼 스튜디오에서 오류를 못 잡는다.

	save("0710.cpp");
}





2022-09-26 23:37:43 GMT+9

/*                         #### 9.26 다섯 번째 강의 ####                          */

#include "stdafx.h"

int main()
{
	//int a = 10;
	//char c = 65;		// 1 바이트 문자, 265 개 문자 표현 가능
	//short s = 65;	
	//wchar_t wc = 65;	// 2 바이트 문자. 육만오천 개, 나라별 언어 설정 가능

	char c = '8';
	wchar_t wc = L'한';	// L 은 2 바이트 문자 앞에 붙여 주는 것. 규칙.

	char szBuffer1[20] = "abcdefg";	// 배열 초기화 방법
	char szBuffer2[20] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', }; // 위와 같은 뜻.
	// 0 에 대응하는 문자 '\0', 널(NULL) 문자라고 한다.
	// 문자열 규칙, 널 문자가 나오면 문자열의 끝으로 본다.
	// char szBuffer[5] = "abcdefg"; 7 개의 문자를 5 칸에 넣으려고 하니 에러. NULL 문자까지 해서 8 칸 줘야 함.
	// 따라서 배열은 표기된 문자열 개수 + 1 이상 선언되어야 한다. (NULL 문자 때문)

	wchar_t szWBuffer[10] = L"abcdefg"; // 알파벳이더라도 2 바이트로 선언하겠다는 뜻
	// 멀티바이트 - 1 바이트 + 2 바이트 방식 혼용. 주는 1 바이트. 해석하는 입장에서 어려움.
	// 유니코드 - 2 바이트. 요즘은 다 이거 쓴다. 





	
	// ==================================================
	// 배 열
	// 1. 만들어진 배열은 연속된 메모리 구조를 가진다.
	// 2. 배열의 이름 타입은 크기 정보를 포함한다.
	// 배열의 인덱스는 0 부터 시작한다.
	// 따라서 선언 개수 - 1 인덱스까지만 접근 가능하다.
	// ==================================================
	int iArr[100] = {};	// 초기에 선언하는 것이 좋다.
	
	printf("%d\n", sizeof(iArr)); // 400

	// iArr[100] 을 접근하면 터지지만 비주얼 스튜디오에서 오류를 못 잡는다.

	save("0713.cpp");
}





2022-09-27 00:14:44 GMT+9

/*                         #### 9.26 다섯 번째 강의 ####                          */

#include "stdafx.h"

// 변수 타입(종류)
// 지역 변수 (Local)
// 전역 변수
// 정적 변수
// 외부 변수


// 메모리 영역
// 스택(stack) 영역
//  - 지역 변수
// 데이터 영역
// 힙 영역
// 코드 영역


// 함수
// 지역 변수, 스택 메모리를 사용하는 문법
// main 부터가 함수. 그래서 main 은 지역변수고, 스택 메모리.
// 무조건 함수다. 함수의 호출로 프로그램을 만들어내는 것.
// Stack, 후입선출. main -> a 함수 호출, 끝 -> b 함수 호출, 끝 -> main 끝. 나중에 들어온 애가 먼저 끝난다.
// 함수에서 사용하는 변수들은 지역 변수이다.
// 지역 변수들은 스택 메모리 영역을 사용한다.


// 스택이란?
// 자료구조의 일종으로, 선입후출 == 후입선출의 구조로 자료를 관리하는 것.


// 함수 선언, 함수의 모양
// (반환 타입) 함수 이름 (입력 인자 타입) 
int Add(int left, int right) {	// stack 영역에 존재. 8 바이트 유지. int, int가 들어오니까
	return left + right;
	// 정수끼리 더해서 리턴값도 정수
	// return 되면 Add는 종료된다.
}

void Test(int a) {
	a = 100;
}



// main 에서 모든 코드를 다 적으면 속도가 더 빨라질 수도 있다.
// 하지만 같은 코드를 여러 번 호출하는 경우가 생긴다. 
// 이럴 때 똑같은 코드를 다시 적는 수고를 덜 수 있다.
// 즉, 함수를 사용하는 이유는 코드의 재사용성 때문이다.
// 재사용성을 위해 모듈화 -> 개발 속도 향상
int main()
{
	int a = 0;
	int b = 0;

	scanf("%d", &a);
	scanf("%d", &b);

	a = Add(a, b);
	printf("결과 값: %d\n\n\n", a);

	Test(a);	// 이거 호출한다고 main 의 a 가 변하지는 않음.
	// Test 안의 a 만 100 으로 변할 뿐이다.


	// =========================
	// 반복문
	// =========================
	// for (반복자 초기화; 반복자 조건 테스트; 반복자 변경) { };
	int iAdd = 0;
	for (int i = 0; i < 10; ++i) iAdd += (i+1);
	// iAdd 에 1~10 까지의 정수의 합이 나오게 된다.

	printf("1 에서 10 까지 정수의 합: %d\n\n\n", iAdd);

	save("0713.cpp");
}





2022-09-28 00:10:09 GMT+9

/*                         #### 9.27 여섯 번째 강의 ####                          */

#include "stdafx.h"


int Add(int left, int right) {	// stack 영역에 존재. 8 바이트 유지. int, int가 들어오니까
	return left + right;
}

void Test(int a) {
	a = 100;
}

int main()
{
	// =========================
	// 반복문
	// =========================
	// for (반복자 초기화; 반복자 조건 테스트; 반복자 변경) { };
	int iAdd = 0;
	
	for (int i = 0; i < 10; ++i) iAdd += (i+1);
	
	int i = 0;
	while (i < 10) {
		++i;
	}

	// 반복문 구문 안에서 사용 가능한 keyword
	// continue; break;

	iAdd = 0;
	for (int i = 0; i < 10; ++i) {	// ++i 대신 i+=2 라고 하는 게 더 빠름. 그냥 continue 설명일 뿐
		if ((i + 1) % 2 == 1) continue;
		// 짝수일 때만 더하는 것
		iAdd += (i + 1);
	}

	//do {

	//} while ();	// 일단 do, 실행한 다음 조건 테스트를 한다. 순서가 다른 것. 1 회는 무조건 실행된다는 것.
	
	
	save("0713.cpp");
}

2022-09-19 19:46:06 GMT+9

﻿#include <iostream>
#include "save.h"
// 주석

int main()
{
    save("소스.cpp");
    
    // 자료형
    int i = 0;

    // 변수

    // 메모리

    return 0;
}



2022-09-19 20:23:23 GMT+9

﻿#include <iostream>
#include "save.h"
// 주석

int main()
{
    // 정수 : char(1), short(2), int(4), long(4), long long(8)
    // 실수 : float(4), double(8)
    
    // 자료형과 변수
    int i = 0;
    unsigned char c = 256;  // unsigned char은 0~255까지 표현(1byte라서). 
    // 255일 때 11111111임. 1이 더해지면 00000000. 즉 256을 넣으면 0이 나옴.
    signed char c2 = 0;

    // 정수 자료형에 한해서, 자료형 앞에 singed, unsigned 키워드를 붙일 수 있다.
    // signed는 음수, 양수를 표현
    // unsigned는 양수만 표현하겠다는 의미
    // 일반적으로 signed는 생략된다.


    // 메모리 (1 Byte) == (8 bit)
    // 1 비트 -> 2 가지 표현
    // 1 비트 == 8 바이트 -> 256 가지 표현
    // 8 바이트가 2 개면 -> 256 * 256 가지 표현
    // 1024 KB -> 1024 MB -> 1024 GB


    save("소스.cpp");
}
}



2022-09-19 22:31:50 GMT+9

﻿/*                         #### 9.19 세 번째 강의 ####                          */
    
#include <iostream>
#include "save.h"
// 주석

int main()
{
    // 정수 : char(1), short(2), int(4), long(4), long long(8)
    // 실수 : float(4), double(8)
    
    // 자료형과 변수
    int i = 0;
    unsigned char c = 256;  
    signed char c2 = 0;
    
    // ↓↓ 3번째 강의 ↓↓

    // 실수형 자료형
    // 부동 소수점 방식
    // float, double
    int a = 4;
    float f = 4.12341f;
    double d = 5.124125f;

    int i1 = 10;
    int i2 = 20;
    int i3 = i1 + (int)f;


    // 정수와 실수는 표현방식이 다르다.
    // 호환되지 않기 때문에, 한쪽 방식으로 변환 후에 서로 계산이 가능하다.
    // 컴포일러가, 암시적으로 변환을 하여 연산하기 때문에, 프로그래머가 주의를 해야 한다. 
    // 명시적으로 변수 타입을 관리해 주는 습관을 가져야 한다.


    // "연산자"
    // 사칙 연산자
    // +, -, *, /, %(모듈러스): 나머지 연산자(정수끼리만 가능)
    int f1 = 34;
    int f2 = 4;
    int f3 = f1 % f2;   // float형에 % 쓰면 빨간줄 나온다.


    // 비교 연산자
    // ==, !=, <, >, <=, >=
    // 0(거짓), 1(참)이라고 알면 오류가 생길 수 있다.
    // 0(거짓), 0이 아닌 수(참)이라고 아는 것이 좋다.
    // 연산의 결과 값 정수타입일 때 (0 거짓, 1 참)
    i = 3 + 4;
    i = 3 < 4;  // 참. 결과값을 1로 리턴한다. 그렇지만 모든 참의 결과값이 1은 아니니 유의하자.

    
    // 증감 연산자
    // ++, --
    // 진위(전치), 후위(후치)
    // 보통 전위 연산자를 쓰는 것이 좋다. 전위 연산자 쓰는 것을 버릇 들여라.
    i = 10;
    printf("%d\n", i++);    // 이러면 10이 출력된다. 후위 연산자라 이 줄에서 가장 마지막에 수행됨. printf가 다 끝난 뒤에 11이 되는 것이다.


    // 논리 연산자
    // &&(둘다 참일 경우 참), ||(둘 중 하나만 참이어도 참)


    // 조건문
    // if, else if, else로 묶어서 사용
    // 연결된 조건 중 하나만 충족하면 해당 구문 수행 중 나머지는 무시
    // 동시에 체크되어야 하는 조건인 경우에는 if 를 새로 시작한다.
    
    // scanf_s("%d", &i);
    if (i == 10) {
        printf("i 에 값이 10 이 입력되었습니다.\n");
    }
    else {
        printf("i 의 값은 10 이 아닙니다. \n");
    }

    
    // 비트 연산자
    // & (비트 곱), | (비트 합), ~ (비트 반전), ^ (xor, 같으면 0/다르면 1)
    // <<, >> (비트 쉬프트)
    i = 1000;
    i = 10 & 11;    // 10
    i = 10 | 11;    // 11
    i = ~10;        // -11, 둘이 계산하면 -1 나옴
    i = 10 ^ 11;    // 1010, 1011 => 0001 == 1


    // <<, >>
    // 비트 이동
    // 2의 승수 단위로 자리수 변경
    // a << n == a * 2^n
    // a >> n == a / 2^n (몫)
    


    save("소스.cpp");
}





2022-09-23 21:55:45 GMT+9

﻿/*                         #### 9.23 네 번째 강의 ####                          */

#include <iostream>    // 전처리기. 우리 코드가 수행되기 전에 먼저 수행된다.
#include "save.h"

// 출혈
// 방어력 감소
// 이동속도 감소
// 공포

// 공격력 증가
// 방어력 증가
// 이동속도 증가
// 공격속도 증가

#define BLEEDING    1
#define DEF_DOWN    2
#define SPD_DOWN    4
#define TERRIFIED   8   

#define ATT_UP      16  
#define DEF_UP      32
#define SPD_UP      64  
#define ATT_SPD_UP  128
// 비트의 각 자리수에 해당되는 숫자들이다.

// define 도 전처리다. 
// BLEEDING 이라 정의해 두었기 때문에 후에 수정하기가 용이하다.
// 유지 보수에 이득이 많다.

int main()
{
    // 정수 : char(1), short(2), int(4), long(4), long long(8)
    // 실수 : float(4), double(8)

    // <<, >>
    // 비트 이동
    // 2의 승수 단위로 자리수 변경
    // a << n == a * 2^n
    // a >> n == a / 2^n (몫)
    
    // ↓ 4 번째 강의
    
    // 전처리기
    // 코드를 컴파일 하기 전에 먼저 수행됨
    // #include 
    // #define 

    {   // 지역 안에 정의된 애가 우선순위가 더 높다.
        unsigned char status = 0;   // 8비트, 비트 하나하나에 버프를 저장해 둘 것이다. 

        status = status | BLEEDING;
        // status |= BLEEDING; 와 같다.
        status |= DEF_DOWN;
        
        if (status & BLEEDING) // 결과가 0 이 아니라면 TRUE.
            printf("캐릭터가 출혈에 의해서 -10 데미지를 당했습니다.\n");
        if (status & SPD_UP)
            printf("캐릭터의 이동속도가 20 % 증가하였습니다.\n");
        
        status &= ~BLEEDING;    // BLEEDING 을 반전한 다음 비트 AND. 디버프 빼기.

        if (status & BLEEDING)
            printf("캐릭터가 출혈에 의해서 -10 데미지를 당했습니다.\n");
        

    }

   save("소스.cpp");
}





2022-09-23 22:44:37 GMT+9

/*                         #### 9.23 �� ��° ���� ####                          */

#include "stdafx.h"

int main()
{
	//int a = 10;
	//char c = 65;		// 1 ����Ʈ ����, 265 �� ���� ǥ�� ����
	//short s = 65;	
	//wchar_t wc = 65;	// 2 ����Ʈ ����. ������õ ��, ���� ��� ���� ����

	// char(1), wchar_t(2) ������ �ڷ��� �߿� ���ڸ� ǥ���ϴµ� ���Ǵ� �ڷ���
	// ���ڴ� �� ���ڿ� ����, ���ڿ� ������ ���踦 ������ ǥ�� �ٷ� �ƽ�Ű�ڵ�ǥ��.
	// �ƽ�Ű�ڵ�ǥ�� 1 ����Ʈ. �� 128 ��. ����� 1 ����Ʈ�� ��� ǥ�� �����ϴ�.
	// �񿵾�� ���ڵ��� 1 ����Ʈ�� �� ���� �� �����Ƿ� 2 ����Ʈ �ڷ��� ���.
	// ������ 2 ����Ʈ ���ڿ��� �ַ�.

	// �ѱ��� ǥ���ϱ� ���ؼ� 2 ����Ʈ ���� ���� �ڷ����� ����Ѵ�.
	
	
	// ================================================
	// �� ��
	// 1. ������� �迭�� ���ӵ� �޸� ������ ������.
	// 2. �迭�� �̸� Ÿ���� ũ�� ������ �����Ѵ�.
	// �迭�� �ε����� 0 ���� �����Ѵ�.
	// ���� ���� ���� - 1 �ε��������� ���� �����ϴ�.
	// ================================================
	int iArr[100] = {};	// �ʱ⿡ �����ϴ� ���� ����.
	
	printf("%d\n", sizeof(iArr)); // 400

	// iArr[100] �� �����ϸ� �������� ���־� ��Ʃ������� ������ �� ��´�.

	save("0710.cpp");
}